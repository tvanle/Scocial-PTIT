generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============== AUTH & USER ==============

model User {
  id              String    @id @default(uuid())
  email           String    @unique
  password        String
  studentId       String?   @unique

  // Profile
  fullName        String?
  avatar          String?
  coverImage      String?
  bio             String?
  dateOfBirth     DateTime?
  gender          Gender?
  phone           String?

  // Status
  isVerified      Boolean   @default(false)
  isActive        Boolean   @default(true)
  lastActiveAt    DateTime?

  // Timestamps
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  posts           Post[]
  comments        Comment[]
  likes           Like[]

  // Follow system
  followers       Follow[]  @relation("Following")
  following       Follow[]  @relation("Followers")

  // Group
  ownedGroups     Group[]   @relation("GroupOwner")
  groupMembers    GroupMember[]

  // Notifications
  sentNotifications     Notification[] @relation("NotificationSender")
  receivedNotifications Notification[] @relation("NotificationReceiver")

  // Refresh tokens
  refreshTokens   RefreshToken[]

  // Chat relations
  conversationParticipants ConversationParticipant[]
  sentMessages             Message[]                 @relation("MessageSender")
  messageReadStatuses      MessageReadStatus[]       @relation("MessageReadBy")

  // Dating
  datingProfile            DatingProfile?
  swipesSent               DatingSwipe[]  @relation("SwipeFrom")
  swipesReceived           DatingSwipe[]  @relation("SwipeTo")
  matchesAsA               DatingMatch[]  @relation("MatchUserA")
  matchesAsB               DatingMatch[]  @relation("MatchUserB")

  // Block
  blockedUsers             UserBlock[]    @relation("BlockedBy")
  blockedByUsers           UserBlock[]    @relation("BlockedUser")

  @@index([email])
  @@index([studentId])
}

model RefreshToken {
  id          String   @id @default(uuid())
  token       String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([token])
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower    User     @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following   User     @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

// ============== POST ==============

model Post {
  id          String      @id @default(uuid())
  content     String?
  authorId    String
  author      User        @relation(fields: [authorId], references: [id], onDelete: Cascade)

  // Privacy
  privacy     PostPrivacy @default(PUBLIC)

  // Timestamps
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  media       Media[]
  comments    Comment[]
  likes       Like[]

  // Group post
  groupId     String?
  group       Group?      @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@index([authorId])
  @@index([groupId])
  @@index([createdAt])
}

model Comment {
  id          String    @id @default(uuid())
  content     String
  authorId    String
  author      User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  postId      String
  post        Post      @relation(fields: [postId], references: [id], onDelete: Cascade)

  // Reply
  parentId    String?
  parent      Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies     Comment[] @relation("CommentReplies")

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
}

model Like {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([postId])
  @@index([userId])
}

// ============== MEDIA ==============

model Media {
  id          String    @id @default(uuid())
  url         String
  type        MediaType
  filename    String
  mimeType    String
  size        Int
  width       Int?
  height      Int?
  duration    Int?      // For video/audio

  postId      String?
  post        Post?     @relation(fields: [postId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())

  @@index([postId])
}

// ============== GROUP ==============

model Group {
  id          String      @id @default(uuid())
  name        String
  description String?
  avatar      String?
  coverImage  String?
  privacy     GroupPrivacy @default(PUBLIC)

  ownerId     String
  owner       User        @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  members     GroupMember[]
  posts       Post[]

  @@index([ownerId])
}

model GroupMember {
  id        String          @id @default(uuid())
  userId    String
  user      User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  groupId   String
  group     Group           @relation(fields: [groupId], references: [id], onDelete: Cascade)
  role      GroupRole       @default(MEMBER)
  status    MemberStatus    @default(PENDING)
  joinedAt  DateTime        @default(now())

  @@unique([userId, groupId])
  @@index([groupId])
  @@index([userId])
}

// ============== NOTIFICATION ==============

model Notification {
  id          String           @id @default(uuid())
  type        NotificationType
  content     String?
  isRead      Boolean          @default(false)

  senderId    String?
  sender      User?            @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)

  receiverId  String
  receiver    User             @relation("NotificationReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  // Reference
  referenceId String?          // postId, commentId, groupId, etc.

  createdAt   DateTime         @default(now())

  @@index([receiverId])
  @@index([senderId])
  @@index([createdAt])
}

// ============== ENUMS ==============

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PostPrivacy {
  PUBLIC
  FOLLOWERS
  PRIVATE
}

enum MediaType {
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
}

enum GroupRole {
  OWNER
  ADMIN
  MODERATOR
  MEMBER
}

enum MemberStatus {
  PENDING
  APPROVED
  REJECTED
  BANNED
}

enum NotificationType {
  LIKE
  COMMENT
  FOLLOW
  GROUP_INVITE
  GROUP_REQUEST
  GROUP_APPROVED
  MENTION
  SYSTEM
  MATCH_CREATED
}

// ============== CHAT ==============

model Conversation {
  id            String            @id @default(uuid())
  type          ConversationType  @default(PRIVATE)
  name          String?
  avatar        String?

  // Denormalized lastMessage for performance
  lastMessageContent   String?
  lastMessageSenderId  String?
  lastMessageCreatedAt DateTime?

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  participants  ConversationParticipant[]
  messages      Message[]

  @@index([updatedAt(sort: Desc)])
}

model ConversationParticipant {
  id              String       @id @default(uuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt        DateTime     @default(now())

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id              String       @id @default(uuid())
  conversationId  String
  conversation    Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId        String
  sender          User         @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  content         String
  type            MessageType  @default(TEXT)
  mediaUrl        String?
  isRead          Boolean      @default(false)

  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  readBy          MessageReadStatus[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
}

model MessageReadStatus {
  id         String   @id @default(uuid())
  messageId  String
  message    Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation("MessageReadBy", fields: [userId], references: [id], onDelete: Cascade)
  readAt     DateTime @default(now())

  @@unique([messageId, userId])
  @@index([userId])
  @@index([messageId])
}

enum ConversationType {
  PRIVATE
  GROUP
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  FILE
}

// ============== DATING ==============

model DatingProfile {
  id          String   @id @default(uuid())
  userId      String   @unique
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  bio         String?
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  photos      DatingProfilePhoto[]
  prompts     DatingProfilePrompt[]
  lifestyle   DatingProfileLifestyle?
  preferences DatingPreferences?
  
  @@index([userId])
}

model DatingProfilePhoto {
  id          String         @id @default(uuid())
  profileId    String
  profile     DatingProfile   @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  url         String
  order       Int             // 0-5 for ordering photos
  
  createdAt   DateTime        @default(now())
  
  @@index([profileId])
  @@index([profileId, order])
}

model DatingProfilePrompt {
  id          String         @id @default(uuid())
  profileId   String
  profile     DatingProfile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  question    String
  answer      String
  
  order       Int            // 0-2 for ordering prompts
  
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  
  @@index([profileId])
  @@index([profileId, order])
}

model DatingProfileLifestyle {
  id          String         @id @default(uuid())
  profileId   String         @unique
  profile     DatingProfile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  education   String?
  job         String?
  smoking     String?        // NEVER, SOMETIMES, REGULARLY
  drinking    String?        // NEVER, SOMETIMES, REGULARLY
  exercise    String?        // NEVER, SOMETIMES, REGULARLY
  height      Int?           // in cm
  religion    String?
  
  updatedAt   DateTime       @updatedAt
  
  @@index([profileId])
}

model DatingPreferences {
  id          String         @id @default(uuid())
  profileId   String         @unique
  profile     DatingProfile  @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  ageMin      Int            @default(18)
  ageMax      Int            @default(99)
  maxDistance Int?           // in km, null = no limit
  gender      Gender?        // Preferred gender
  
  updatedAt   DateTime       @updatedAt
  
  @@index([profileId])
}

model DatingSwipe {
  id          String      @id @default(uuid())
  fromUserId  String
  fromUser    User        @relation("SwipeFrom", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUserId    String
  toUser      User        @relation("SwipeTo", fields: [toUserId], references: [id], onDelete: Cascade)
  action      SwipeAction

  createdAt   DateTime    @default(now())

  @@unique([fromUserId, toUserId])
  @@index([fromUserId])
  @@index([toUserId])
  @@index([fromUserId, toUserId, action])
}

model DatingMatch {
  id          String   @id @default(uuid())
  userAId     String
  userA       User     @relation("MatchUserA", fields: [userAId], references: [id], onDelete: Cascade)
  userBId     String
  userB       User     @relation("MatchUserB", fields: [userBId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

enum SwipeAction {
  LIKE
  PASS
}

// ============== BLOCK ==============

model UserBlock {
  id            String   @id @default(uuid())
  blockerId     String
  blocker       User     @relation("BlockedBy", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedUserId String
  blockedUser   User     @relation("BlockedUser", fields: [blockedUserId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())

  @@unique([blockerId, blockedUserId])
  @@index([blockerId])
  @@index([blockedUserId])
}
